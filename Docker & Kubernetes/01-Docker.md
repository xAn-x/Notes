## What is a Container

A way to package application with all necessary dependencies and config. It is _portable_ and can be shared easily.

## What is **Docker**

- Containerization platform for developing, packaging, shipping & running applications.
- Run applications in an isolated env (container).
- Makes deployment & development easy.  

## Docker Architecture

![[Pasted image 20241217115847.png]]

## Docker vs Virtual Machines

![[Pasted image 20241217120241.png]]


| Feature                  | Docker                                              | Virtual Machine (VM)                                 |
| ------------------------ | --------------------------------------------------- | ---------------------------------------------------- |
| **Hypervisor**           | Containerization (Kernel-level)                     | Type 1 (bare-metal) or Type 2 (hosted)               |
| **Resource Use**         | Lightweight, shares host OS kernel                  | Heavyweight, emulates entire OS                      |
| **Boot Time**            | Very fast                                           | Relatively slow                                      |
| **Portability**          | High, runs on any system with Docker                | Moderate, dependent on hypervisor & OS               |
| **Isolation**            | Less isolated than VMs, shares kernel               | Highly isolated, separate OS instance                |
| **Security**             | Less secure than VMs, shared kernel vulnerabilities | More secure, isolated OS instance                    |
| **Scalability**          | Easier to scale, lightweight containers             | Can be scaled, but resource intensive                |
| **Example (Conceptual)** | `docker run hello-world` (runs a simple container)  | `vmware run myVM.vmdk` (runs a full virtual machine) |


**In short:** Docker is faster, lighter, and easier to manage for applications, while VMs offer stronger isolation and security but are more resource-intensive.  Choose Docker for application deployment and VMs for complete OS isolation and security.

## Docker Components

**Docker Flow**
![[Pasted image 20241217120547.png]]

### Components of Docker:

- _Docker File:_ Text file containing inst. to run an app.
  
- _Docker Registry:_ Central repo for storing and distributing docker imgs (Docker Hub).
  
- _Docker Image:_ read-only template containing everything needed to run an application: code, runtime, system tools, libraries, settings.
  
  Blueprint or a snapshot of an application's environment. It's created using a `Dockerfile`.

- _Docker Container:_ running instance of a Docker image. Isolated from other host processes, but shares same host's kernel.

### Dockerfile containing instruction

```Dockerfile
# Specify the base image:version
FROM node:20 

# Dir where we need to do the installation 
WORKDIR /my_app

# Copy everything to /my_appp
COPY . /my_app

# run this command to download all dependecies
RUN npm install

# Port on thich u need to run your application
EXPOSE 3000

# What commands to run when we exec the docker-image
CMD ['npm','start']
```

### Build image using Dockerfile

```sh
# use Dockerfile to create a image
# -t: tag for the image
docker build -t "v2".

# list all docker image
docker image ls 

# run image -- containerization
# -d: detach
# --rm: remove conatiner when we stop 
# -p: expose localhost 3000 to docker's port 3000
# --name: name of conainter
docker run -d --rm --name "test-app" -p 3000:3000 [[image-id:tag]]

# process-status of all running container
docker ps
# -a for all containers
docker ps -a

# stop docker instance
docker stop [[container-name]]

# remove a conatiner
docker rm [[container-name]]

# remove a image
docker rmi [[image-name:tag ]]
```

> [!NOTE]
> Whenever u change your web-app u need to re-build the docker image.

### Docker Volumes

Docker volumes are the preferred mechanism **for persisting data generated by and used by Docker containers**.  They are essentially directories or files on the host machine that are specifically managed by Docker to provide persistent storage that is separate from the container's filesystem.

Here's a breakdown of key aspects:

* **Persistence:**  When a container is removed, its filesystem is typically deleted.  Data stored within the container itself is lost.  Volumes, however, are persistent.  They survive even if the container is removed or the image is deleted.

* **Management:** Docker manages volumes separately from containers.  This allows for easier management and backup/restore of data.

* **Sharing:** Volumes can be shared between multiple containers, providing a mechanism for data sharing and collaboration between applications.

* **Isolation:** While persistent, volumes are still isolated from the host's main filesystem, offering a degree of protection.

* **Flexibility:** Volumes can be created and managed using Docker commands, and they can be mounted at different locations within containers.

**Why use Docker Volumes instead of just mounting a host directory?**

While you *can* mount a host directory directly into a container, volumes offer several advantages:

* **Portability:**  Volumes are more portable.  You can easily move a volume between different hosts or containers without worrying about path changes.  Host directory mounts are tied to the specific host machine.

* **Backup and Restore:**  Docker provides tools and mechanisms for backing up and restoring volumes, simplifying data management.

* **Simplified Management:** Docker handles volume management, making it easier to track and control persistent data.


**In short:** Docker volumes provide a robust, portable, and manageable way to handle persistent data for your Docker containers, ensuring data survives container lifecycles and allowing for efficient data sharing.

```sh
# run the docker image and persist the voulum [files in dir]
docker run -d --rm -v:volume_name:[[dir/file to persist]] -p 3000:3001 [[image_id]]
```


### Important Docker commands
 
| Command          | Description                                    | Common Options                                                                                                                                                                                |
| ---------------- | ---------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `docker run`     | Creates and starts a container                 | `-d` (detached), `-p` (port mapping), `-v` (volume mount), `-e` (environment variable), `--name` (container name), `-it` (interactive-terminal if prog involve IO/interaction with terminal). |
| `docker ps`      | Lists running containers                       | `-a` (all containers), `-l` (last created)                                                                                                                                                    |
| `docker stop`    | Stops a running container                      | `<container ID or name>`                                                                                                                                                                      |
| `docker start`   | Starts a stopped container                     | `<container ID or name>`                                                                                                                                                                      |
| `docker kill`    | Forcefully stops a container                   | `<container ID or name>`                                                                                                                                                                      |
| `docker rm`      | Removes a stopped container                    | `<container ID or name>`                                                                                                                                                                      |
| `docker rmi`     | Removes one or more images                     | `<image ID or name>`, `-f` (force)                                                                                                                                                            |
| `docker build`   | Builds a Docker image from a Dockerfile        | `-t` (tag), `-f` (Dockerfile path)                                                                                                                                                            |
| `docker images`  | Lists Docker images                            |                                                                                                                                                                                               |
| `docker exec`    | Executes a command in a running container      | `<container ID or name>`, `<command>`                                                                                                                                                         |
| `docker logs`    | Shows logs from a container                    | `<container ID or name>`                                                                                                                                                                      |
| `docker commit`  | Creates a new image from a container's changes | `<container ID>`, `<new image name>`                                                                                                                                                          |
| `docker network` | Manage Docker networks                         | `create`, `ls`, `rm`, etc.                                                                                                                                                                    |
| `docker volume`  | Manage Docker volumes                          | `create`, `ls`, `rm`, etc.                                                                                                                                                                    |
| `docker system`  | Manage Docker system resources                 | `prune`, `df`, etc.                                                                                                                                                                           |
| `docker login`   | Login to docker-hub                            |                                                                                                                                                                                               |
| `docker push`    | Pushes Docker image to a registery             | `<image-name>`                                                                                                                                                                                |
| `docker pull`    | Pulls docker image from a registery            | `<image-name>`                                                                                                                                                                                |

### Docker Network

Allow containers to communicate with each other and the outside world. They provide isolation and control over container networking.

![[Pasted image 20241217203915.png]]

**Types:**

- **bridge (default):** Containers on the same bridge network can communicate. Isolated from the host's network by default.
- **host:** Containers share the host's network namespace. No isolation.
- **overlay:** Supports multi-host networking (Docker Swarm, Kubernetes). Containers across different hosts can communicate.
- **macvlan:** Containers get their own MAC address and appear as separate devices on the host's network.
- **none:** Containers have no network interface.

**Example (bridge network):**

```sh
# Create a network
docker network create my-net
```

```python
# my_app.py

# Here we need to specify network-name as host

import pymysql

def create_connection():
	return pymysql.connect(
		host="my-net", # rather than 'localhost' use network name
		user="root", # MySQL Username
		password="root", # MySQL Password
		database="Employee"
	) 

# -- rest-program ---
```

```sh
# build your docker image
docker build .

# Run containers on the network
docker run -d --name db --net my-net mysql:5.7
docker run -d --name python_app --net my-net [[python-image]]

# Test connectivity (from the db container, ping the web container)
docker exec db ping web  
# Should succeed if on same network
```

**Key Points:**

- `docker network ls` lists existing networks.
- `docker network inspect <network_name>` shows network details.
- `--net=<network_name>` specifies the network for a container.
- Isolation levels vary by network type. Choose the appropriate type based on your needs (security, scalability).

**Security Note:** Carefully consider network isolation and access control when designing your Docker deployments. Avoid exposing sensitive services directly to the host network unless absolutely necessary

### Docker Compose

**Core Idea:** Docker Compose defines and runs multi-container applications.  It uses a YAML file (`docker-compose.yml`) to specify the services (containers), their dependencies, and networking.

**Benefits:**

* Simplified multi-container application management.
* Easier to define and replicate environments (dev, test, prod).
* Improved reproducibility and consistency.


**Example (web app with database):**

**`docker-compose.yml`:**

```yaml
# docker-compose.yaml

version: "3.9" 
services:
	web: # name of service u want
	    image: nginx:latest # which img to run
	    ports:  # what port 
	      - "80:80"
	    volumes: # volume to persist 
	      - ./html:/usr/share/nginx/html
	    depends_on: # other service on which it depends
	       - db: # make sure first run db, using service-healthy
			 condition: service_healthy
	    enviorment: # if u have some env vars
		    - var_name=value

	db:
	    image: mysql:5.7
	    environment:
	      - MYSQL_ROOT_PASSWORD=mysecretpassword
	    ports:
	      - "3306:3306"
	    volumes:
	      - db_data:/var/lib/mysql

	mypyapp:
		build: ./ # build img using Dockerfile
		depends_on:
			- db:
			  condition: service_healthy
		# enable interactive-terminal
		stdin_open: true
		tty: true
		# port binding
		ports:
			- 3000:3000
		constainer-name: 'my-py-app'
```

**Explanation:**

* **`version`:** Specifies the Compose file version.
* **`services`:** Defines the containers.
  * **`web`:**  Uses the `nginx:latest` image, maps port 80, mounts a volume, and depends on the `db` service.
  * **`db`:** Uses the `mysql:5.7` image, sets an environment variable, maps port 3306, and uses a named volume.
* **`volumes`:** Defines named volumes for persistent data (database).

```sh
# run all services
docker-compose up -d 

# can also run individual services
docker-compose run -d db

# stop all services
docker-compse down

# stop all service and also volumes
docker-compse down -v

# check status
docker-compose ps -a
```

**Commands:**

* `docker-compose up -d`: Builds, creates, and starts the containers in detached mode (background).
* `docker-compose down`: Stops and removes the containers, networks, and volumes.
* `docker-compose ps`: Lists running containers.
* `docker-compose logs`: Shows logs from the containers.


**To run the example:**

1. Create a directory with `docker-compose.yml` and an `html` directory containing your website files.
2. Navigate to that directory in your terminal.
3. Run `docker-compose up -d`.
4. Access your website at `http://localhost`.


**Key Points:**

* The `docker-compose.yml` file is declarative; it describes the desired state.
* Compose handles the complexities of networking and dependencies automatically.
*  Named volumes ensure data persistence even if containers are removed.  Use them for data that needs to survive container restarts.

>[!Note]
>Internally docker-compose create a network automatically so that services can interact with each other.
>
>You can manually specify network inside docker-compose if u want.
